import { join, sep } from 'path';
import { lstatSync, readdirSync } from 'fs';
import rimraf from 'rimraf';

const unsafeChars = /[^-_a-zA-Z0-9]/g;
const windowsReserved = /^(con|prn|aux|nul|com[0-9]|lpt[0-9])(\..*)?$/i;
const escapeSeq = /%([_0-9a-fA-F]+)%/g;

export default class LevelDBLib {
  /**
   * It escapes a namespace to a safe file name.
   * This function is injective.
   * @param {string} namespace namespace of Level DB
   * @returns {string}
   */
  static escapeNamespace(namespace) {
    if (!namespace) return '%_%';
    if (namespace.match(windowsReserved)) {
      return `%_%${namespace}`;
    }
    return namespace.replace(unsafeChars, substr => `%${substr.charCodeAt(0).toString(16)}%`);
  }

  /**
   * Reversed function of escapeNamespace.
   * @param {string} escapedNamedpace file name generated by escapeNamespace
   * @returns {string}
   */
  static unescapeNamespace(escapedNamedpace) {
    return escapedNamedpace.replace(escapeSeq, (substr, group) => {
      if (group === '_') return '';
      return String.fromCharCode(parseInt(group, 16));
    });
  }

  static restoreMetadata(path) {
    const isDirectory = (source) => {
      try {
        return lstatSync(source).isDirectory();
      } catch (e) {
        return false;
      }
    };
    const getDirectories = source => (isDirectory(source) ? readdirSync(source).map(name => join(source, name)).filter(isDirectory) : []);
    const pages = getDirectories(path).map(p => LevelDBLib.unescapeNamespace(p.split(sep)[1]));
    return pages.reduce((accumulator, p) => {
      const dbPath = join(path, LevelDBLib.escapeNamespace(p));
      const directoryCreated = lstatSync(dbPath).ctime; // Not correct on Linux
      const latestFileModified = new Date(Math.max(...readdirSync(dbPath).map(name => join(dbPath, name)).map(f => lstatSync(f).mtimeMs)));
      return Object.assign(accumulator, {
        [p]: {
          created: directoryCreated,
          modified: latestFileModified,
          active: 0,
        },
      });
    }, {});
  }

  /**
   * Closes database
   * @param {*} y y instance
   * @returns {Promise}
   */
  static closeDatabase(y) {
    // Because y.close waits whenTransactionsFinished forever,
    // we copied y.close and removed whenTransactionsFinished.
    if (y.connector.destroy != null) {
      y.connector.destroy();
    } else {
      y.connector.disconnect();
    }
    y.connector.disconnect();
    y.db.destroyTypes();
    const g = y.db.destroy();
    for (;;) {
      const i = g.next();
      if (i.done) {
        break;
      }
    }
    return y.db.whenTransactionsFinished();
  }

  /**
   * Deletes database. The database must be closed before deleting.
   * @param {string} path parent directory of each levelDB database
   * @param {string} page raw page name of wiki page
   * @returns {Promise}
   */
  static deleteDatabase(path, page) {
    const dbpath = join(path, LevelDBLib.escapeNamespace(page));
    return new Promise((resolve, reject) => {
      rimraf(dbpath, {}, (err) => {
        if (err) {
          reject(err);
          return;
        }
        resolve();
      });
    });
  }
}
